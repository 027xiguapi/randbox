/**
 * Helpers module for RandBox.js
 * Contains utility functions for array manipulation, uniqueness, and other helpers
 */

import { testRange, slice, range, RandBox } from './core.js';

export function capitalize(word: string): string {
    return word.charAt(0).toUpperCase() + word.substr(1);
}

export function mixin(this: RandBox, obj: Record<string, any>): RandBox {
    for (var func_name in obj) {
        (this as any)[func_name] = obj[func_name];
    }
    return this;
}

/**
 *  Given a function that generates something random and a number of items to generate,
 *    return an array of items where none repeat.
 *
 *  @param {Function} fn the function that generates something random
 *  @param {Number} num number of terms to generate
 *  @param {Object} options any options to pass on to the generator function
 *  @returns {Array} an array of length `num` with every item generated by `fn` and unique
 *
 *  There can be more parameters after these. All additional parameters are provided to the given function
 */
export function unique<T>(this: RandBox, fn: (...args: any[]) => T, num: number, options?: any): T[] {
    testRange(
        typeof fn !== "function",
        "RandBox: The first argument must be a function."
    );

    var comparator = function(arr: T[], val: T) { return arr.indexOf(val) !== -1; };

    if (options) {
        comparator = options.comparator || comparator;
    }

    var arr: T[] = [], count = 0, result: T, MAX_DUPLICATES = num * 50, params = slice.call(arguments, 2);

    while (arr.length < num) {
        var clonedParams = JSON.parse(JSON.stringify(params));
        result = fn.apply(this, clonedParams);
        if (!comparator(arr, result)) {
            arr.push(result);
            // reset count when unique found
            count = 0;
        }

        if (++count > MAX_DUPLICATES) {
            throw new RangeError("RandBox: num is likely too large for sample set");
        }
    }
    return arr;
}

/**
 *  Shuffle an array using the Fisher-Yates shuffle
 */
export function shuffle<T>(this: RandBox, arr: T[]): T[] {
    var copy = slice.call(arr);
    var length = copy.length;
    var i;

    // While there remain elements to shuffle…
    while (length) {
        // Pick a remaining element…
        i = Math.floor(this.random() * length--);

        // And swap it with the current element.
        var temp = copy[length];
        copy[length] = copy[i];
        copy[i] = temp;
    }

    return copy;
}

/**
 *  Return a random element from the provided array
 */
export function pick<T>(this: RandBox, arr: T[], count?: number): T | T[] {
    if (arr.length === 0) {
        throw new RangeError("RandBox: Cannot pick() from an empty array");
    }
    if (!count || count === 1) {
        return arr[this.natural({max: arr.length - 1})];
    } else {
        return this.shuffle(arr).slice(0, count);
    }
}

/**
 *  Return a single random element from the provided array
 */
export function pickone<T>(this: RandBox, arr: T[]): T {
    if (arr.length === 0) {
      throw new RangeError("RandBox: Cannot pickone() from an empty array");
    }
    return arr[this.natural({max: arr.length - 1})];
}

/**
 *  Return `count` random elements from the provided array
 */
export function pickset<T>(this: RandBox, arr: T[], count: number): T[] {
    if (count === 0) {
        return [];
    }
    if (arr.length === 0) {
        throw new RangeError("RandBox: Cannot pickset() from an empty array");
    }
    if (count < 0) {
        throw new RangeError("RandBox: Count must be a positive number");
    }
    if (!count || count === 1) {
        return [ this.pickone(arr) ];
    } else {
        var array = arr.slice(0);
        var end = array.length;
        var self = this;

        return this.n(function () {
            var index = self.natural({max: --end});
            var value = array[index];
            array[index] = array[end];
            return value;
        }, Math.min(end, count));
    }
}

/**
 *  Given an array of items and their weights, return a randomly selected item
 */
export function weighted<T>(this: RandBox, arr: T[], weights: number[], trim?: boolean): T {
    if (arr.length !== weights.length) {
        throw new RangeError("RandBox: Length of array and weights must match");
    }

    // scan weights array and sum valid entries
    var sum = 0;
    var val;
    for (var weightIndex = 0; weightIndex < weights.length; ++weightIndex) {
        val = weights[weightIndex];
        if (isNaN(val)) {
            throw new RangeError("RandBox: All weights must be numbers");
        }

        if (val > 0) {
            sum += val;
        }
    }

    if (sum === 0) {
        throw new RangeError("RandBox: No valid entries in array weights");
    }

    // select a value within range
    var selected = this.random() * sum;

    // find array entry corresponding to selected value
    var total = 0;
    var lastGoodIdx = -1;
    var chosenIdx;
    for (weightIndex = 0; weightIndex < weights.length; ++weightIndex) {
        val = weights[weightIndex];
        total += val;
        if (val > 0) {
            lastGoodIdx = weightIndex;

            if (selected <= total) {
                chosenIdx = weightIndex;
                break;
            }
        }
    }

    if (typeof chosenIdx === 'undefined') {
        chosenIdx = lastGoodIdx;
    }

    var chosen = arr[chosenIdx];
    trim = (typeof trim === 'undefined') ? false : trim;
    if (trim) {
        arr.splice(chosenIdx, 1);
        weights.splice(chosenIdx, 1);
    }

    return chosen;
}

/**
 *  Pad a number with leading characters
 */
export function pad(number: number | string, width: number, padChar?: string): string {
    // Default pad to 0 if none provided
    padChar = padChar || '0';
    // Convert number to a string
    var numberStr = number + '';
    return numberStr.length >= width ? numberStr : new Array(width - numberStr.length + 1).join(padChar) + numberStr;
}

/**
 *  Gives an array of n random terms
 *
 *  @param {Function} fn the function that generates something random
 *  @param {Number} n number of terms to generate
 *  @returns {Array} an array of length `n` with items generated by `fn`
 *
 *  There can be more parameters after these. All additional parameters are provided to the given function
 */
export function n<T>(this: RandBox, fn: (...args: any[]) => T, count?: number): T[] {
    testRange(
        typeof fn !== "function",
        "RandBox: The first argument must be a function."
    );

    if (typeof count === 'undefined') {
        count = 1;
    }
    var i = count, arr: T[] = [], params = slice.call(arguments, 2);

    // Providing a negative count should result in a noop.
    i = Math.max( 0, i );

    for (null; i--; null) {
        arr.push(fn.apply(this, params));
    }

    return arr;
}

/**
 *  Return a random number based on a normal distribution
 */
export function normal(this: RandBox, options?: { mean?: number; dev?: number }): number {
    options = options || {};

    // Default mean of 0, standard deviation of 1
    var mean = typeof options.mean !== 'undefined' ? options.mean : 0;
    var dev = typeof options.dev !== 'undefined' ? options.dev : 1;

    return (this.random as any).normal ? (this.random as any).normal(mean, dev) :
           mean + dev * (this.random as any).boxMuller();
}

// Export collection for easy prototype extension
export const helpers = {
    capitalize,
    mixin,
    unique,
    shuffle,
    pick,
    pickone,
    pickset,
    weighted,
    pad,
    n,
    normal
};